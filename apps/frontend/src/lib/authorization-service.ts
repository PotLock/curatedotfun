import { CrosspostClient } from "@crosspost/sdk";
import { generateNonce, NearAuthData } from "near-sign-verify";
import { OPEN_CROSSPOST_PROXY_API } from "../config";
import {
  AUTHORIZATION_EVENTS,
  authorizationEvents,
} from "./authorization-events";
import { toast } from "../hooks/use-toast";
import { Web3Auth } from "@web3auth/modal";

let clientInstance: CrosspostClient | null = null;

/**
 * Gets or creates a CrosspostClient instance
 * @returns The CrosspostClient instance
 */
export function getClient(): CrosspostClient {
  if (!clientInstance) {
    clientInstance = new CrosspostClient({
      baseUrl: OPEN_CROSSPOST_PROXY_API,
    });
  }
  return clientInstance;
}

/**
 * Creates the data payload needed for the authorization process.
 * This involves signing a message with the user's NEAR wallet.
 * @param web3auth - Web3Auth instance
 * @param getNearAccount - Function to get NEAR account from Web3Auth context
 * @returns Promise resolving to the authorization payload
 */
export async function createAuthorizationPayload(
  web3auth: Web3Auth,
  getNearAccount: () => Promise<any>,
): Promise<NearAuthData> {
  if (!web3auth || !getNearAccount) {
    throw new Error("Web3Auth and getNearAccount are required");
  }

  const userInfo = await web3auth.getUserInfo();
  const accountId = userInfo.email || userInfo.name || "unknown";

  const message = `I authorize crosspost to post on my behalf to connected social platforms using my NEAR account: ${accountId}`;
  const nonce = generateNonce();
  const recipient = "crosspost.near";
  const callbackUrl = location.href;

  try {
    // Get NEAR account from Web3Auth context
    const nearAccount = await getNearAccount();
    if (!nearAccount || !nearAccount.keyPair) {
      throw new Error("Failed to get NEAR account from Web3Auth");
    }

    // Sign the message using the NEAR key pair
    const messageBuffer = Buffer.from(message);
    const signature = nearAccount.keyPair.sign(messageBuffer);

    return {
      message,
      nonce: Buffer.from(nonce),
      recipient,
      callback_url: callbackUrl,
      signature: Buffer.from(signature.signature).toString("base64"),
      account_id: accountId,
      public_key: nearAccount.keyPair.getPublicKey().toString(),
    };
  } catch (error) {
    console.error("Authorization payload creation error:", error);
    throw new Error(
      "Failed to create authorization payload: " +
        (error instanceof Error ? error.message : "Unknown error"),
    );
  }
}

/**
 * Authorizes the app by verifying the payload with the backend,
 * persisting the authorization state, and notifying listeners.
 * @param authorizationPayload - The payload generated by createAuthorizationPayload
 * @returns Promise resolving to true if authorization was successful, false otherwise.
 * @throws Error if the authorization process fails unexpectedly.
 */
export async function authorize(
  authorizationPayload: NearAuthData,
): Promise<boolean> {
  toast({
    title: "Authorizing...",
    description: "Verifying your authorization with the server",
    variant: "default",
  });

  try {
    const client = getClient();
    client.setAuthentication(authorizationPayload);

    await client.auth.authorizeNearAccount();

    localStorage.setItem("crosspost:authorized", "true");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZED);

    toast({
      title: "Authorized",
      variant: "success",
    });
    return true;
  } catch (error) {
    toast({
      title: "Authorization Failed",
      description:
        error instanceof Error
          ? error.message
          : "Failed to authorize with the server",
      variant: "destructive",
    });
    console.error("Authorization error:", error);
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
    throw error;
  }
}

/**
 * Unauthorizes the app by removing persisted state, notifying listeners,
 * and potentially informing the backend.
 * @returns Promise resolving when unauthorization is complete.
 */
export async function unauthorize(): Promise<void> {
  toast({
    title: "Revoking Authorization...",
    description: "Removing your authorization from the server",
    variant: "default",
  });

  try {
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);

    toast({
      title: "Authorization Revoked",
      description: "Successfully removed your authorization",
      variant: "success",
    });
  } catch (error) {
    toast({
      title: "Revocation Failed",
      description:
        error instanceof Error
          ? error.message
          : "Failed to revoke authorization",
      variant: "destructive",
    });
    console.error("Unauthorization error:", error);
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
  }
}
